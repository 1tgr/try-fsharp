<html>
    <head>
        <title>FSIndex</title>
        <script src="/_utils/script/json2.js"></script> 
        <script src="/_utils/script/jquery.js"></script> 
        <script src="/_utils/script/jquery.couch.js"></script> 
        <script src="jquery.livesearch.js"></script>
        <script src="mustache.js"></script>

        <script>
function words(s) {
    var i, word = "", ret = [];
    var isSymbol, symbols = ":'";

    for (i = 0; i < s.length; i++) {
        isSymbol = symbols.indexOf(s[i]) > -1;
        if (s[i] == " " || isSymbol) {
            if (word.length > 0) {
                ret.push(word);
            }

            if (isSymbol) {
                word = s[i];
            } else {
                word = "";
            }
        } else {
            word += s[i];
        }
    }

    if (word.length > 0) {
        ret.push(word);
    }

    return ret;
}

function parse(term) {
    var i, w = words(term);
    var state = 0;
    var info = { };
    var error = null;

    for (i = 0; i < w.length; i++) {
        if (error) {
            throw error;
        }

        switch (state) {
        case 0: // expecting name or ':'
            switch (w[i]) {
            case ":":
                info.prototype = [];
                state = 2;
                break;

            default:
                info.name = w[i];
                state = 1;
                break;
            }
            break;

        case 1: // expecting ':' or '->'
            if (w[i] === ":") {
                info.prototype = [];
                state = 2;
            } else if (w[i] === "->") {
                info.prototype = [ info.name ];
                delete info.name;
                state = 2;
            } else {
                error = "expecting ':' or '->'";
            }
            break;

        case 2: // expecting type
            if (w[i] === "->") {
                error = "expecting type";
            } else {
                info.prototype.push(w[i]);
                state = 3;
            }
            break;

        case 3: // expecting ->
            if (w[i] === "->") {
                state = 2;
            } else {
                error = "expecting ->";
            }
            break;
        }
    }
   
    return info;
}

function makeQuery(info) {
    if (info.name && info.prototype) {
        throw "can't search by name and prototype yet";
    } else if (info.name) {
        return {
            view: "app/by-name",

            format: function(rows) {
                return { byName: rows };
            },

            options: {
                startkey: info.name,
                endkey: info.name + "\ufff0"
            }
        };
    } else if (info.prototype) {
        var options;
        if (info.prototype.length > 0) {
            var last = info.prototype[info.prototype.length - 1];
            info.prototype.pop();
            if (last === "_") {
                options = {
                    startkey: info.prototype.concat(null),
                    endkey: info.prototype.concat({ "\ufff0": "" })
                };
            } else {
                options = {
                    startkey: info.prototype.concat(last),
                    endkey: info.prototype.concat(last + "\ufff0")
                };
            }
        } else {
            options = {
                startkey: [ null ],
                endkey: [ { "\ufff0": "" } ]
            };
        }

        return {
            view: "app/by-signature",

            format: function(rows) {
                var i;

                for (i = 0; i < rows.length; i++) {
                    rows[i].signature = formatSignature(rows[i].key);
                }

                return { bySignature: rows };
            },

            options: options
        };
    } else {
        return null;
    }
}

function formatSignature(prototype) {
    var i, a = [];

    for (i = 0; i < prototype.length; i++) {
        if (typeof prototype[i] === "string") {
            a.push(prototype[i]);
        } else {
            a.push(JSON.stringify(prototype[i]));
        }
    }

    return a.join(" -> ");
}

$(function() {
    var db = $.couch.db("fsindex");

    db.openDoc(
        "_design/app",
        {
            success: function(ddoc) {
                $("#search").livesearch({
                    minimumSearchLength: 1,
                    searchCallback: function(term) {
                        var query;

                        // try {
                            var info = parse(term);
                            query = makeQuery(info);
                        // } catch (s) {
                        //    alert(s);
                        //    return;
                        //}

                        if (query) {
                            query.options.limit = 100;
                            query.options.success = function(results) {
                                var data = { };

                                if (results.rows.length === 0) {
                                    data.rows = [];
                                } else {
                                    data.rows = query.format(results.rows);
                                }

                                var s = Mustache.to_html(ddoc.templates["search-results"], data);
                                $("#results").html(s);
                            }
                               
                            db.view(query.view, query.options);
                        } else {
                            var s = Mustache.to_html(ddoc.templates["search-results"], { rows: [] });
                            $("#results").html(s);
                        }
                    }
                });
            }
       });
});
        </script>
    </head>
    <body>
        <div>
            <label for="search">Search for:</label>
            <input id="search"></input>
        </div>
        <div id="results">
        </div>
    </body>
</html>
